package org.schema.game.common.controller.database.tables;

import org.schema.common.util.linAlg.Vector3i;
import org.schema.game.common.data.player.inventory.FreeItem;
import org.schema.game.common.data.world.Sector;
import org.schema.game.common.data.world.StellarSystem;
import org.schema.game.server.controller.EntityNotFountException;

import java.io.IOException;
import java.sql.*;
import java.util.Map;

public class SectorTable extends Table {

	public SectorTable(TableManager m, Connection c) {
		super("SECTORS", m, c);
	}

	public static long updateOrInsertSector(Connection c, long id, Vector3i pos, int protectionMode, Map<Integer, FreeItem> items, int type, long stellarID, boolean transientSector, long last_replenished) throws SQLException, IOException {

//		System.err.println("[DATABASE] UPDATING SECTOR: " + pos + " trans: " + transientSector);

		Statement s = c.createStatement();

		if(stellarID < 0) {
			Vector3i posFromSector = StellarSystem.getPosFromSector(pos, new Vector3i());

			ResultSet stellQuery = s.executeQuery("SELECT ID FROM SYSTEMS WHERE X = " + posFromSector.x + " AND Y = " + posFromSector.y + " AND Z = " + posFromSector.z + ";");

			stellQuery.next();
			stellarID = stellQuery.getLong(1);
		}

		ResultSet query = s.executeQuery("SELECT ID FROM SECTORS WHERE X = " + pos.x + " AND Y = " + pos.y + " AND Z = " + pos.z + ";");

		if(query.next()) {

			PreparedStatement p = c.prepareStatement(
					"UPDATE SECTORS SET (TYPE,NAME,ITEMS,PROTECTION,STELLAR,TRANSIENT, LAST_REPLENISHED) = (" +
							"CAST(? AS INT)," +
							"CAST(? AS VARCHAR(64))," +
							"CAST(? AS BIGINT)," +
							"CAST(? AS INT)," +
							"CAST(? AS BIGINT)," +
							"CAST(? AS BOOLEAN)," +
							"CAST(? AS BIGINT)" +
							") WHERE ID = " + "CAST(? AS BIGINT)" + ";");
			p.setInt(1, type);
			p.setString(2, "default");
			p.setLong(3, 0L);
			p.setInt(4, protectionMode);
			p.setLong(5, stellarID);

			p.setBoolean(6, transientSector);

			p.setLong(7, last_replenished);

			p.setLong(8, id);
			p.execute();

			p.close();

		} else {
			if(id >= 0) {
				System.err.println("[DATABASE] Sector ID not found: " + id + " at pos" + pos);
			}
			PreparedStatement p = c.prepareStatement(
					"INSERT INTO SECTORS(X,Y,Z,TYPE,NAME,ITEMS,PROTECTION,STELLAR,TRANSIENT, LAST_REPLENISHED) VALUES(" +
							"CAST(? AS INT)," +
							"CAST(? AS INT)," +
							"CAST(? AS INT)," +
							"CAST(? AS INT)," +
							"CAST(? AS VARCHAR(64))," +
							"CAST(? AS BIGINT)," +
							"CAST(? AS TINYINT)," +
							"CAST(? AS BIGINT)," +
							"CAST(? AS BOOLEAN)," +
							"CAST(? AS BIGINT)" +
							");", Statement.RETURN_GENERATED_KEYS);
			p.setInt(1, pos.x);
			p.setInt(2, pos.y);
			p.setInt(3, pos.z);
			p.setInt(4, type);
			p.setString(5, "default");
			p.setLong(6, 0L);
			p.setInt(7, protectionMode);
			p.setLong(8, stellarID);
			p.setBoolean(9, transientSector);
			p.setLong(10, last_replenished);

			p.executeUpdate();
			ResultSet generatedKeys = p.getGeneratedKeys();
			generatedKeys.next();
			id = generatedKeys.getLong(1);
			p.close();
		}
		SectorItemTable.updateOrInsertItems(s, id, items);
		s.close();
		return id;
	}

	public static Vector3i getSector(Connection c, String uid, Vector3i out) throws SQLException, EntityNotFountException {

		Statement s = c.createStatement();
		String limit = "";
		ResultSet r = s.executeQuery("SELECT X, Y, Z FROM ENTITIES WHERE UID = '" + uid + "';");
		s.close();
		if(r.next()) {
			out.set(r.getInt(1), r.getInt(2), r.getInt(3));
		} else {
			throw new EntityNotFountException("Could not find Entity: " + uid);
		}
		return out;
	}

	@Override
	public void define() {
		addColumn("ID", "BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1)", true);
		addColumn("X", "INT NOT NULL");
		addColumn("Y", "INT NOT NULL");
		addColumn("Z", "INT NOT NULL");
		addColumn("TYPE", "INT NOT NULL");
		addColumn("NAME", "VARCHAR(64) not null");
		addColumn("ITEMS", "BIGINT NOT NULL");
		addColumn("PROTECTION", "INT NOT NULL");
		addColumn("STELLAR", "INT NOT NULL");
		addColumn("TRANSIENT", "BOOLEAN DEFAULT true not null");
		addColumn("LAST_REPLENISHED", "BIGINT DEFAULT 0 not null");

		addIndex("secCoordIndex", true, "X", "Y", "Z");
		addIndex("secStellarIndex", "STELLAR");
		addIndex("secTypeIndex", "TYPE");
	}

	public void removeSector(Vector3i pos) {
		Statement s = null;
		try {
			s = c.createStatement();
			//			"UPDATE SECTORS SET (X,Y,Z,TYPE,NAME,ITEMS,PROTECTION,STELLAR) = (" +

			s.executeUpdate("DELETE FROM SECTORS WHERE X = " + pos.x + " AND Y = " + pos.y + " AND Z = " + pos.z + ";");

			return;

		} catch(SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				s.close();
			} catch(Exception e) {
				e.printStackTrace();
			}
		}
	}

	public void updateOrInsertSector(Sector sector) throws SQLException, IOException {
		if(!sector.hasChangedForDb()) {
			//no nead to insert sector
			return;
		}

		long id = updateOrInsertSector(c, sector.getDBId(), sector.pos, sector.getProtectionMode(), sector.getItems(), sector.getSectorType().ordinal(), -1, sector.isTransientSector(), sector.getLastReplenished());
		sector.setDBId(id);
		sector.setChangedForDb(false);
	}

	public Vector3i getSector(String uid, Vector3i out) throws SQLException, EntityNotFountException {
		return getSector(c, uid, out);
	}

	public void insertNewSector(Vector3i pos, int protectionMode, Map<Integer, FreeItem> items, int type, boolean transientSector, long lastReplenishedTime) throws SQLException, IOException {
		updateOrInsertSector(c, -1, pos, protectionMode, items, type, -1, transientSector, lastReplenishedTime);
	}

	public boolean loadSector(Vector3i sectorPos, Sector sector) throws IOException {
		Statement s = null;
		try {
			long t = System.currentTimeMillis();
			long tot = System.currentTimeMillis();
			long create = 0;
			long queryTime = 0;
			long items = 0;
			long meta = 0;

			s = c.createStatement();
			create = System.currentTimeMillis() - t;
			t = System.currentTimeMillis();
			//			"UPDATE SECTORS SET (X,Y,Z,TYPE,NAME,ITEMS,PROTECTION,STELLAR) = (" +

			ResultSet query = s.executeQuery("SELECT ID, TYPE, NAME, ITEMS, PROTECTION, TRANSIENT, LAST_REPLENISHED FROM SECTORS WHERE X = " + sectorPos.x + " AND Y = " + sectorPos.y + " AND Z = " + sectorPos.z + ";");
			queryTime = System.currentTimeMillis() - t;
			t = System.currentTimeMillis();
			if(query.next()) {
				sector.setDBId(query.getInt(1));
				sector.pos = new Vector3i(sectorPos);
				String name = query.getString(3);

				m.getSectorItemTable().loadItems(s, sector);
				items = System.currentTimeMillis() - t;
				t = System.currentTimeMillis();
				sector.addMetaItems();

				sector.setProtectionMode(query.getInt(5));
				items = System.currentTimeMillis() - t;
				t = System.currentTimeMillis();

				long total = System.currentTimeMillis() - tot;
				sector.setTransientSector(query.getBoolean(6));

				sector.setLastReplenished(query.getLong(7));

				if(total > 40) {
					System.err.println("[DATABASE] WARNING: Loading sector: " + sectorPos + " took long: " + total + "ms; createStatement " + create + "ms, query: " + queryTime + "ms, items: " + items + "ms, meta: " + meta + "ms");
				}
//				System.err.println("LOADED SECTOR: "+sector.toDetailString());
				//				System.err.println("LOADED SECTOR: "+sector+"; transient: "+sector.isTransientSector());
				return true;
			}
		} catch(SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				s.close();
			} catch(Exception e) {
				e.printStackTrace();
			}
		}

		return false;
	}

	@Override
	public void afterCreation(Statement s) {

	}

	@Deprecated
	public void createSectorsTable() throws SQLException {
		{
			Statement s = c.createStatement();

			s.execute("DROP TABLE SECTORS if exists;");

			s.execute("CREATE CACHED TABLE SECTORS(" +
					"BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1), " +
					"X INT not null, " +
					"Y INT not null, " +
					"Z INT not null, " +
					"TYPE INT not null, " +
					"NAME VARCHAR(64) not null, " +
					"ITEMS BIGINT not null, " + //5kb
					"PROTECTION INT not null, " +
					"STELLAR INT not null, " +
					"TRANSIENT BOOLEAN DEFAULT true not null, " +
					"LAST_REPLENISHED BIGINT DEFAULT 0 not null, " +
					"primary key (ID)" +
					");");

			s.execute("create index secTypeIndex on SECTORS(TYPE);");
			s.execute("create index secStellarIndex on SECTORS(STELLAR);");
			s.execute("create unique index secCoordIndex on SECTORS(X,Y,Z);");
			s.close();
		}
	}

}
