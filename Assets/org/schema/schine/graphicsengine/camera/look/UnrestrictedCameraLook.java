package org.schema.schine.graphicsengine.camera.look;

import javax.vecmath.Quat4f;
import javax.vecmath.Vector3f;

import org.schema.common.FastMath;
import org.schema.schine.graphicsengine.camera.Camera;

import com.bulletphysics.linearmath.Transform;

public class UnrestrictedCameraLook implements MouseLookAlgorithm {

	private Camera camera;
	private Quat4f rotation = new Quat4f();

	public UnrestrictedCameraLook(Camera camera) {
		this.camera = camera;
	}

	@Override
	public void fix() {
		
	}

	@Override
	public void force(Transform t) {
	}

	/**
	 * dx, dy are between [-1.0d, 1.0d]
	 * x/ySensitivity are between [0.0d, 1.0d]
	 * <p/>
	 * Recalculates upVector and view Vectors for dx and dy mouse rotation
	 */
	@Override
	public void mouseRotate(boolean server, float dx, float dy, float dz, float xSensitivity, float ySensitivity, float zSensibilits) {

		Vector3f view = new Vector3f(camera.getForward()); //Vector3fTools.subtract(targetVector, position);
		Vector3f upVector = new Vector3f(camera.getUp()); //Vector3fTools.subtract(targetVector, position);
		Vector3f rightVector = new Vector3f(camera.getRight()); //Vector3fTools.subtract(targetVector, position);

		//Mouse-Y Rotation, rotation on our view vector x up vector
		Vector3f vCross = new Vector3f();
		vCross.cross(camera.getForward(), camera.getUp());
		Vector3f vRot = new Vector3f(vCross);
		vRot.normalize();

		//dy must be negated for some reason
		float yRotAngle = dy * ySensitivity; //angle
		if (yRotAngle > 1) yRotAngle = 1;
		if (yRotAngle < -1) yRotAngle = -1;

		//don't rotate if no delta
		Quat4f tempA;
		if (dy == 0.0d) {
			tempA = new Quat4f(0, 0, 0, 1);
		} else {
			tempA = new Quat4f(
					vRot.x * FastMath.sin(yRotAngle),
					vRot.y * FastMath.sin(yRotAngle),
					vRot.z * FastMath.sin(yRotAngle),
					FastMath.cos(yRotAngle));
		}

		//Mouse-X Rotation, rotation on our up vector
		vRot = new Vector3f(camera.getUp());
		vRot.normalize();

		//dx must be negated for some reason
		float xRotAngle = -dx * xSensitivity; //angle
		if (xRotAngle > 1) xRotAngle = 1;
		if (xRotAngle < -1) xRotAngle = -1;

		Quat4f tempB;
		if (dx == 0.0d) {
			tempB = new Quat4f(0, 0, 0, 1);
		} else {
			tempB = new Quat4f(
					0,
					1,
					0,
					FastMath.cos(xRotAngle));
		}

		//We mutiply both rotations to get THE rotation, am I wrong here?
		//tempA rotationQuat generated by moving the mouse up/down
		//tempB rotationQuat generated by moving the mouse left/right
		//THE rotation is assigned to tempB...
		//		tempB = tempA.getMultiplicationBy(tempB).getNormalized();
		rotation.mul(tempA, tempB);
		rotation.normalize();

		Quat4f mTmpConjugated = new Quat4f();

		mTmpConjugated.conjugate(rotation);

		//we apply the rotation to the view vector, that way we can get the new targetVector
		Quat4f viewQuat = new Quat4f(camera.getForward().x, camera.getForward().y, camera.getForward().z, 0);
		Quat4f result = new Quat4f();
		result.mul(rotation, viewQuat);
		result.mul(mTmpConjugated);
		//			result = rotation.getMultiplicationBy(viewQuat).getMultiplicationBy(mTmpConjugated);
		view.x = result.x;
		view.y = result.y;
		view.z = result.z;

		view.normalize();
		camera.setForward(view);

		//find "rotated" target vector
		//			targetVector = Vector3f.add(position, view);

		//we apply the rotation to the up vector
		Quat4f upQuat = new Quat4f(camera.getUp().x, camera.getUp().y, camera.getUp().z, 0);
		result.mul(rotation, upQuat);
		result.mul(mTmpConjugated);
		//			result = rotation.getMultiplicationBy(upQuat).getMultiplicationBy(mTmpConjugated);
		upVector.x = result.x;
		upVector.y = result.y;
		upVector.z = result.z;

		upVector.normalize();
		camera.setUp(upVector);

		//we apply the rotation to the up vector
		Quat4f rightQuat = new Quat4f(camera.getRight().x, camera.getRight().y, camera.getRight().z, 0);
		result.mul(rotation, rightQuat);
		result.mul(mTmpConjugated);
		//					result = rotation.getMultiplicationBy(upQuat).getMultiplicationBy(mTmpConjugated);
		rightVector.x = result.x;
		rightVector.y = result.y;
		rightVector.z = result.z;

		rightVector.normalize();
		camera.setRight(rightVector);

		//finished
	}

	@Override
	public void lookTo(Transform n) {
		
	}
}
